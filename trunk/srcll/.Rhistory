n
x
length(x)
cfunction
compileCode
inline:::compileCode
?match
match
library(dlm)
?dlm
## seasonal component for quarterly data#
dlmModSeas(4, dV = 3.2)
x <- matrix(runif(6,4,10), nc = 2); x
dlmModReg(x)
dlmModReg(x, addInt = FALSE)
data(NelPlo)#
### multivariate local level -- seemingly unrelated time series#
buildSu <- function(x) {#
  Vsd <- exp(x[1:2])#
  Vcorr <- tanh(x[3])#
  V <- Vsd %o% Vsd#
  V[1,2] <- V[2,1] <- V[1,2] * Vcorr#
  Wsd <- exp(x[4:5])#
  Wcorr <- tanh(x[6])#
  W <- Wsd %o% Wsd#
  W[1,2] <- W[2,1] <- W[1,2] * Wcorr#
  return(list(#
              m0 = rep(0,2),#
              C0 = 1e7 * diag(2),#
              FF = diag(2),#
              GG = diag(2),#
              V = V,#
              W = W))#
}
head(NelPlo)
head(NelPlo,30)
dim(NelPlo)
NelPlo
dlmMLE
dlmLL
library(rdonlp2)
library(rdonlp)
library(Rdonlp)
library(rdonlp2)
library(Rdonlp2)
?Rdonlp2
?Rdonlp
?rdonlp
help(pack="Rdonlp2")
?donlp2
library(depmix)
?depmix
data(speed)#
mod <- dmm(nsta=2,itemt=c(1,2)) # gaussian and binary items#
fit1 <- fitdmm(dat=speed,dmm=mod)
?donlp2
library(Rdonlp2)
y=library(Rdonlp2)
y
datasets
y$datasets
?datasets
library(depmix)
?depmix
data(speed)#
mod <- dmm(nsta=2,itemt=c(1,2)) # gaussian and binary items#
fit1 <- fitdmm(dat
=speed,dmm=mod)
summary(fit1)
library(depmix)
?depmix
library(Rhmm)
?Rhmm
?HMMSet
library(RHmm)
?RHmm
?HMMSet
    data(geyser)#
    obs <- geyser$duration
head(geyse)
head(geyser)
plot(as.ts(geyser$waiting))
plot(as.ts(geyser$duration))
plot(as.ts(geyser[1:50,]))
plot(as.ts(geyser[1:100,]))
cor(geyser)
    ResGeyser1 <- HMMFit(obs)
    ResGeyser2 <- HMMFit(obs, nStates=3, paramBW=list(verbose=1, init="KMEANS"))#
    # fit a 2 states of a mixture of 3 normal distributions#
    # for data_mixture#
    data(data_mixture)#
    ResMixture <- HMMFit(data_mixture, nStates=2, nMixt=3, dis="MIXTURE")#
    summary(ResMixture)#
    # geyser data - 3 states HMM with bivariate normal distribution#
    ResGeyser<-HMMFit(obs=as.matrix(geyser), nStates=3)#
    # multiple samples discrete observations#
    data(weather)#
    ResDiscrete <- HMMFit(obs=weather, nStates=3, dis="DISCRETE")
ResDiscrete
library(nnet)
?multinom
multinom
library(depmixS4)
?depmix
        data(speed)#
        depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))
mod <- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))	mod
	# create a 2 state model with one continuous and one binary response	data(speed)	mod <- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))	# print the model, formulae and parameter values	mod
?library
library(depmixS4)
?depmix
?stats4
library(stats4)
?stats4
?statmodel
library(modeltools)
?fit
methods(fit)
getAnywhere(fit)
fit[depmixS4]
fit[1]
[2]
modeltools:::fit
depmixS4:::fit
depmix
?depmix
?depmix.fit
fit
	data(speed)	# 2-state model on the RTs of the speed data with random 	# starting values for the transition pars (without those EM does not get off the ground)	set.seed(1)	mod <- depmix(rt~1,data=speed,nstates=2,trstart=runif(4))	# fit the model	mod1 <- fit(mod)	mod1 # to see the logLik and optimization information	# to see the parameters	summary(mod1)
mod
library(modeltools)
library(depmixS4)
?depmix.fit
ls()
?depmix-class
?"depmix-class"
library(depmixS4)
?"depmix-class"
?depmix.fit
library(depmixS4)
?depmix.fit
data(speed)#
# 2-state model on the RTs of the speed data with random #
# starting values for the transition pars (without those EM does not get off the ground)#
set.seed(1)#
mod <- depmix(rt~1,data=speed,nstates=2,trstart=runif(4))#
# fit the model#
mod1 <- fit(mod)
mod1
summary(mod1)
?depmix
?llratio
library(depmixS4)
?llratio
?depmix
library(depmixS4)
?llratio
library(depmixS4)
?llratio
library(depmixS4)
?llratio
?balance
posterior
?balance
library(flexmix)
?flexmix
?balance
?flexmix
?response-class
?"response-class"
?speed
data(speed)
head(speed)
head(speed,24)
max(speed$Pacc)
?"response-classes"
?"response-class"
?glm
library(depmixS4)
?balance
?"depmix-class"
?em
?"depmix.fi"
?"depmix.fit"
?depmix
mod# to see the ordering of parameters to use in setparsmod <- setpars(mod, value=1:npar(mod))mod
# create a 2 state model with one continuous and one binary responsedata(speed)mod <- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))# print the model, formulae and parameter valuesmod# to see the ordering of parameters to use in setparsmod <- setpars(mod, value=1:npar(mod))mod
mod <- setpars(mod, getpars(mod,which="fixed"))mod
?llratio
?"response-class"
?GLMresponse-class
?"GLMresponse-class"
?glm
?response
library(depmixS4)x <- rnorm(100)xd <- data.frame(x,1)mod <- depmix(x~1,ns=2,nt=100,trst=runif(4))viterbi(mod)
fm <- fit(mod)viterbi(fm)
data(speed)rt <- speed$rtmod <- depmix(rt~1,ns=2,nt=439,trst=runif(4))fm <- fit(mod)viterbi(fm)
viterbi
library(depmixS4)data(speed)rt <- speed$rtmod <- depmix(rt~1,ns=2,nt=439,trst=runif(4))fm <- fit(mod)viterbi(fm)
viterbi
library(depmixS4)data(speed)rt <- speed$rtmod <- depmix(rt~1,ns=2,nt=439,trst=runif(4))fm <- fit(mod)viterbi(fm)
plot(as.ts(viterbi(fm))
)
plot(as.ts(viterbi(fm)))
trstart=c(0.899,0.101,0.084,0.916)instart=c(0.5,0.5)resp <- c(5.52,0.202,0.472,0.528,6.39,0.24,0.098,0.902)mod <- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()),trstart=trstart)# 	respstart=resp,trstart=trstart,instart=instart)logLik(mod)mod1 <- fit(mod)ll <- logLik(mod1)# # Test optimization using Rdonlp2# trstart=c(0.899,0.101,0,0.01,0.084,0.916,0,0)instart=c(0.5,0.5)resp <- c(5.52,0.202,0.472,0.528,6.39,0.24,0.098,0.902)mod <- depmix(list(rt~1,corr~1),data=speed,transition=~Pacc,nstates=2,family=list(gaussian(),multinomial()),	respstart=resp,trstart=trstart,instart=instart)logLik(mod)mod1 <- fit(mod)ll <- logLik(mod1)
post <- cbind(viterbi(mod1),speed$Pacc)
plot(as.ts(post))
cor(post)
mod@ntimes
mod1@ntimes
plot(rnorm(100))#
par(fig=c(0, 1/2, 0, 1/2), new=T)#
plot(seq(-2,2,length=300),dnorm(seq(-2,2,length=300)),type="l", axes =#
F, xlab="", ylab="")
A <- matrix(1:4,2,2)B <- matrix(1:10,10)init <- matrix(1:2,1)
A
B
init
ct <- A*B
apply(B,1,prod,A)
apply(B,1,,A)
A*B[1,]
apply(B,1,*,A)
apply(B,1,"*",A)
?array
ct <- array(apply(B,1,"*",A),c(2,2,10))
ct
library(depmixS4)data(speed)mod <- depmix(list(rt~1,corr~1),data=speed,nstates=2,family=list(gaussian(),multinomial()))# print the model, formulae and parameter valuesmodx=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)
x
setwd("/Users/ivisser/Documents/projects/depmixProject/depmixNew/rforge/depmix/trunk/srcll")
source("lystig2.R")
x1=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)source("lystig2.R")x2=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)all.equal(x1,x2)
x1=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)source("lystig2.R")x2=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)all.equal(x1,x2)
x1=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)x1b=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),439)source("lystig2.R")x2=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),mod@ntimes)x2b=lystig(mod@init,mod@trDens,apply(mod@dens,c(1,3),prod),439)all.equal(x1,x2)all.equal(x1b,x2b)
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,10))
ct
B
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,10))
A
B
ct
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,5))
ct
A
B
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,5),byrow=T)
?array
methods(summary)
showMethods(summary)
A[1,]*B[1,]
A[2,]*B[1,]
apply(B,1,"*",A),c(2,2,5)
apply(B,1,"*",A)
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,5,2)
)
ct
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,5))ct <- array(apply(B,1,"*",A),c(5,2,2))ct
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,5))ct <- array(apply(B,1,"*",A),c(5,2,2))ct[1,]
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(2,2,5))ct <- array(apply(B,1,"*",A),c(5,2,2))ct[1,,]
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(5,2,2))ct[1,,]
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]
A[1,]*B[1,]A[2,]*B[1,]
A <- matrix(1:4,2,2)B <- matrix(1:10,5)init <- matrix(1:2,1)ct <- array(apply(B,1,"*",A),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]
ct <- array(apply(B,1,"*",A),c(2,5,2))ct[1,,]ct[,1,]ct[,,1]
ct <- array(apply(B,1,"*",A),c(2,2,5))ct[1,,]ct[,1,]ct[,,1]
ct <- array(apply(A,1,"*",B),c(2,2,5))ct[1,,]ct[,1,]ct[,,1]
ct <- array(apply(A,1,"*",B),c(2,5,2))ct[1,,]ct[,1,]ct[,,1]
ct <- array(apply(A,1,"*",B),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]
A[1,]*B[1,]A[2,]*B[1,]
ct <- array(apply(A,1,"*",B),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]A[1,]*B[1,]A[2,]*B[1,]
t(ct)
ct <- array(apply(A,1,"*",B),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]A[1,]*B[1,]A[2,]*B[1,]A[1,]*B[2,]A[2,]*B[2,]
ct[2,,]
ct <- array(apply(t(A),1,"*",B),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]A[1,]*B[1,]A[2,]*B[1,]
ct <- array(apply(A,1,"*",B),c(5,2,2))ct[1,,]ct[,1,]ct[,,1]A[1,]*B[1,]A[2,]*B[1,]
sessionInfo()
A <- array(1:20,c(5,2,2))B <- matrix(1:10,5)
A
B
A <- array(1:20,c(2,2,5))
A
B <- matrix(1:10,5)
B
rbind(A[1,]*B[1,],A[2,]*B[1,])
rbind(A[1,,1]*B[1,],A[2,,1]*B[1,])
rbind(A[1,,2]*B[2,],A[2,,2]*B[2,])
rbind(A[1,,3]*B[2,],A[2,,3]*B[2,])
apply(B,1,"*",A)
c(sort(apply(B,1,"*",A)))
ct <- numeric(0)for(i in 1:5){ct <- c(ct,(A[1,,i]*B[1,],A[2,,i]*B[1,])}
ct <- numeric(0)
ct
ct <- numeric(0)for(i in 1:5){ct <- c(ct,A[1,,i]*B[1,],A[2,,i]*B[1,])}
ct
