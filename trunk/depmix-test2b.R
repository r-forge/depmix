# # Single operator learning model# setwd("/Users/ivisser/Documents/projectsCurrent/depmixProject/depmixNew/code/depmix/trunk/")source("depmixS4.r")source("classes.r")source("hmModel.R")library(Rdonlp2)# genereer dataalpha=.5 # learning ratentrials=5pderr <- numeric(ntrials)pderr[1] <- 0.5for (i in 1:(ntrials-1)) {	pderr[i+1] <- pderr[i]*alpha}ncases=100mdt <- data.frame(resp=rbinom(ntrials*ncases,1,rep(pderr,ncases)))datamat <- matrix(mdt$resp,,ntrials,byrow=TRUE)plot(apply(datamat,FUN=mean,MAR=2))lengths=rep(ntrials,ncases)# # Model met identity linkfun# rModels <- list(  list(	rModel(formula=resp~1,data=mdt,family=multinomial("identity"),pstart=c(1-pderr[1],pderr[1]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial("identity"),pstart=c(1-pderr[2],pderr[2]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial("identity"),pstart=c(1-pderr[3],pderr[3]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial("identity"),pstart=c(1-pderr[4],pderr[4]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial("identity"),pstart=c(1-pderr[5],pderr[5]))))trstart=rbind(cbind(rep(0,ntrials-1),diag(ntrials-1)),c(rep(0,ntrials-1),1))trstart=c(t(trstart))instart=c(1,rep(0,ntrials-1))mod <- depmix(rModels=rModels,data=mdt,trstart=trstart,instart=instart,ntimes=lengths)logLik(mod)# # optimize without constraints, this should simply return the proportion errors at each t:apply(datamat,FUN=mean,MAR=2)allpars <- getpars(mod)nonfixed <- c(30+1:10)pars <- allpars[nonfixed]optpars <- pars[c(2,4,6,8,10)]llike <- function(optpars) {	pars <- c(rbind(1-optpars,optpars))	allpars[nonfixed] <- pars	mod <- setpars(mod,allpars)	-logLik(mod)}llike(optpars)# optpars=runif(5)llike(optpars)par.l=rep(0,5)par.u=rep(1,5)control.fun <- function(x) {	print(x$par)}optpars=runif(5)cntrl <- donlp2.control(te3=T, difftype=1, epsx=1e-3,iterma=50,report=TRUE)res5 <- donlp2(optpars,llike,control=cntrl,par.l=par.l,par.u=par.u,control.fun=control.fun)allpars[nonfixed] <- c(rbind(1-res5$par,res5$par))mod <- setpars(mod,allpars)logLik(mod)# modelsetwd("/Users/ivisser/Documents/projectsCurrent/depmixProject/depmixNew/code/depmix/trunk/")source("depmixS4.r")source("classes.r")source("hmModel.R")# genereer dataalpha=.25 # learning ratentrials=5pderr <- numeric(ntrials)pderr[1] <- 0.5for (i in 1:(ntrials-1)) {	pderr[i+1] <- pderr[i]*alpha}ncases=100mdt <- data.frame(resp=rbinom(ntrials*ncases,1,rep(pderr,ncases)))datamat <- matrix(mdt$resp,,ntrials,byrow=TRUE)plot(apply(datamat,FUN=mean,MAR=2))lengths=rep(ntrials,ncases)rModels <- list(  list(	rModel(formula=resp~1,data=mdt,family=multinomial(),pstart=c(1-pderr[1],pderr[1]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial(),pstart=c(1-pderr[2],pderr[2]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial(),pstart=c(1-pderr[3],pderr[3]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial(),pstart=c(1-pderr[4],pderr[4]))),list(  rModel(formula=resp~1,data=mdt,family=multinomial(),pstart=c(1-pderr[5],pderr[5]))))trstart=rbind(cbind(rep(0,ntrials-1),diag(ntrials-1)),c(rep(0,ntrials-1),1))trstart=c(t(trstart))instart=c(1,rep(0,ntrials-1))mod <- depmix(rModels=rModels,data=mdt,trstart=trstart,instart=instart,ntimes=rep(ntrials,ncases))logLik(mod)# # optimize without constraints# allpars <- getpars(mod)nonfixed <- c(30+1:5*2)pars <- allpars[nonfixed]optpars <- parsllike <- function(optpars) {# 	pars <- c(0,optpars[1],0,optpars[2],0,optpars[3],0,optpars[4])	allpars[nonfixed] <- optpars	mod <- setpars(mod,allpars)	-logLik(mod)}llike(optpars)apply(datamat,FUN=mean,MAR=2)cntrl <- donlp2.control(te3=T, difftype=2, epsx=1e-3, iterma=200)res4 <- donlp2(optpars,llike,control=cntrl)allpars[nonfixed] <- res4$parmod <- setpars(mod,allpars)linv <- function(eta,base=1) {	pp <- numeric(length(eta))	if(any(is.infinite(eta))) {		pp[which(is.infinite(eta))] <- 1	} else {		expb <- exp(eta)		sumb <- sum(expb)		pp[base] <- 1/sumb		pp[-base] <- expb[-base]/sumb	}	return(pp)}round(apply(cbind(rep(0,4),res4$par),1,linv),3)[,2]apply(datamat,FUN=mean,MAR=2)# # idem maar met een constraint op de pars# allpars <- getpars(mod)nonfixed <- c(20+1:8)pars <- allpars[nonfixed]optpars <- pars[c(1,3,5,7)]# maak startwaardes aan die voldoen aan constraint:alpha=.6p0=.5perr=p0for (i in 1:3){perr[i+1]<-perr[i]*alpha}# specificatie hangt af van wat je met gefixeerde parameters moet doen# wordt de lower en upper bound op de gefixeerde waarde gezet?# startwaardes gegenereerd met alpha .55 en beginkans .5# p[k] kans op error op trial (= in toestand) k # lower en upper bounds# de kans op een error in de eerste toestand is gefixeerd op de upper bound# p[1] wordt gefixeerd op .5# p[2] is helemaal vrij# p[3] - p[10] worden met constraints geschat, en zijn allemaal afhankelijk van p[1] en p[2]# bounds parameters, alleen de bound van de tweede parameter is belangrijk, # bounds niet-lineaire constraintsnlin.l <- nlin.u <- rep(0,2)# constrain p[3] tm p[10] nlcon3 <- function(x){x[2]/x[1] * x[2] -x[3]}nlcon4 <- function(x){x[2]/x[1] * x[3] -x[4]}# over de afgeleides zit ik te twijfelen, want p[1] zit wel in de formule, maar p[1] is gefixeerd.# ik zou denken dat de afgeleide naar p[1] dan gelijk is aan 0, maar stel, dat je# p[1] zou schatten, dan is de partiele afgeleide naar de eerste parameter # van constraint nlconk gelijk aan # -x[2]*x[k-1]/x[1]^2dnlcon3 <- function(x){# de afgeleide van de eerste constraint is een uitzondering # omdat je hier x[2]^2 in de constraintfunctie hebt staan ipv. x[2]*x[(k-1)!=2]# de afgeleides vanaf x[4] hebben allemaal dezelfde structuurc(-x[2]*x[2]/x[1]^2,2*x[2]/x[1],-1,rep(0,2))}dnlcon4 <- function(x){ c(-x[2]*x[3]/x[1]^2,x[3]/x[1],x[2]/x[1],-1,rep(0,6)) }attr(nlcon3, "gr") <- dnlcon3attr(nlcon4, "gr") <- dnlcon4nlin=list(nlcon3,nlcon4)par.l=c(0,rep(0,3))par.u=c(1,rep(1,3))optpars <- perrllike <- function(optpars) {	pars <- c(rbind(1-optpars,optpars))	allpars[nonfixed] <- pars	mod <- setpars(mod,allpars)	-mod@loglike(mod)$logLike}llike(optpars)cntrl <- donlp2.control(te3=T)Rprof("Rprof2.out")res5 <- donlp2(optpars,llike,control=cntrl,par.l=par.l,par.u=par.u,	nlin=nlin,nlin.u=nlin.u, nlin.l=nlin.l)summaryRprof("Rprof2.out")res5$par[2]/res5$par[1]res5$par[3]/res5$par[2]res5$par[4]/res5$par[3]allpars[nonfixed] <- c(rbind(1-res5$par,res5$par))mod <- setpars(mod,allpars)mod@loglike(mod)$logLike# # Discrimination learning voorbeeld# # # LCA voorbeeld# # # Andere voorbeelden# 