# # hmModel class combining rModels, trModels and init pars to define a# loglikelihood function# # Ingmar Visser, 15-3-2007setClass("hmModel",  representation(rModels="list",		trModels="list", 		initModel="trinModel", # init		trans="array", # A		stationary="logical",		logdens="array", # for B		parameters="numeric",		ntimes="numeric",		nstates="numeric",		nresp="numeric",		npar="numeric",		nlin="numeric",		fitted="logical",		message="character"	))hmModel <- function(rModels,trModels,initModel,ntimes=NULL,STATION=FALSE) {		stationary=STATION	nstates <- length(rModels)	nresp <- length(rModels[[1]])		# make appropriate ntimes	if(is.null(ntimes)) {		if(is.list(rModels[[1]])) ntimes <- nrow(rModels[[1]][[1]]@y) else ntimes <- nrow(rModels[[1]]@y)	}		nt <- sum(ntimes)		# count the number of parameters		npars <- nstates	for(i in 1:nstates) {		npars <- npars + sum(sapply(rModels[[i]],npar))	}	npars <- npars + sum(sapply(trModels,npar))		# get the parameter list		parameters <-c(initModel@parameters$coefficients)	for(i in 1:nstates) {		parameters <- c(parameters,getpars(trModels[[i]]))	}	for(i in 1:nstates) {		for(j in 1:nresp) {			parameters <- c(parameters,getpars(rModels[[i]][[j]]))		}	}		# make appropriate array for transition probs	if(stationary) trans <- array(0,c(1,nstates,nstates))	else trans <- array(0,c(nt,nstates,nstates))		# make appropriate array for observation densities	dens <- array(,c(nt,nresp,nstates))			# compute observation and transition densities	for(i in 1:nstates) {		for(j in 1:nresp) {			dens[,j,i] <- logDens(rModels[[i]][[j]]) # remove this rModels as an argument from the call to setpars		}		trans[,,i] <- logDens(trModels[[i]])	}		# get trans on a probability scale instead of logarithmic scale	trans <- exp(trans)		new("hmModel",rModels=rModels,trModels=trModels,initModel=initModel,		trans=trans,stationary=stationary,logdens=dens,		parameters=parameters,ntimes=ntimes,nstates=nstates,nresp=nresp,npar=npars,nlin=0,fitted=FALSE,message="not-fitted")}# accessor functionssetMethod("npar","hmModel",	function(object) return(object@npar))setGeneric("nlin", function(object, ...) standardGeneric("nlin"))setMethod("nlin","hmModel",	function(object) return(object@nlin))setGeneric("freepars", function(object, ...) standardGeneric("freepars"))setMethod("freepars","hmModel",	function(object) {		free <- sum(!getpars(object,which="fixed"))		free <- free-nlin(object)		free	})setGeneric("nobs", function(object, ...) standardGeneric("nobs"))setMethod("nobs", signature(object="hmModel"),	function(object, ...) {		nrow(object@rModels[[1]][[1]]@x)	})setGeneric("logLik", function(object, ...) standardGeneric("logLik"))setMethod("logLik",signature(object="hmModel"),	function(object,method="lystig") { # TODO: initial dens and response densities are recomputed here, but this is also done in setpars at least for the response densities !!!!!!!!		if(method=="fb") ll <- fb(exp(logDens(object@initModel)),object@trans,exp(apply(object@logdens,c(1,3),sum)),object@ntimes,object@stationary)$logLike		if(method=="lystig") ll <- lystig(exp(logDens(object@initModel)),object@trans,exp(apply(object@logdens,c(1,3),sum)),object@ntimes,object@stationary)$logLike		attr(ll, "df") <- freepars(object)		attr(ll, "nobs") <- nobs(object)		class(ll) <- "logLik"		ll	})setMethod("AIC", signature(object="hmModel"),	function(object, ..., k=2){		c(-2 * logLik(object) + freepars(object) * k)	})setGeneric("BIC", function(object, ...) standardGeneric("BIC"))setMethod("BIC", signature(object="hmModel"),	function(object, ...){		c(-2 * logLik(object) + freepars(object) * log(nobs(object)))	})setMethod("show","hmModel",function(object) {	if(object@fitted) cat("Optimization information: ", object@message, "\n")	cat("Initial state probabilties model \n")	print(object@initModel)	cat("\n")	for(i in 1:object@nstates) {		cat("Transition model for state (component)", i,"\n")		print(object@trModels[[i]])		cat("\n")	}	cat("\n")	for(i in 1:object@nstates) {		cat("Response model(s) for state", i,"\n\n")		for(j in 1:object@nresp) {			cat("Response model for response",j,"\n")			print(object@rModels[[i]][[j]])			cat("\n")		}		cat("\n")	}})setMethod("setpars","hmModel",	function(object,values,which="pars",...) {		# note that the which argument is unused, included for possible later use		if(!(length(values)==npar(object))) stop("Argument 'values' has incorrect length")		bp <- npar(object@initModel)		# TODO: recompute initial densities if pars have changed		object@initModel=setpars(object@initModel,values[1:bp],which=which)		bp <- bp+1		values <- values[bp:npar(object)]		for(i in 1:object@nstates) {			bp <- npar(object@trModels[[i]])			switch(which,				"pars"= {					if(!all(getpars(object@trModels[[i]]) == values[1:bp])) {						object@trModels[[i]] <- setpars(object@trModels[[i]],values[1:bp])						# recompute transition densities if pars have changed						object@trans[,,i] <- exp(logDens(object@trModels[[i]]))					}				},				"fixed" = {					object@trModels[[i]] <- setpars(object@trModels[[i]],values[1:bp],which="fixed")				}			)			bp <- bp+1			values <- values[bp:length(values)]		}		for(i in 1:object@nstates) {			for(j in 1:object@nresp) {				bp <- npar(object@rModels[[i]][[j]])				switch(which,					"pars" = {						if(!all(getpars(object@rModels[[i]][[j]]) == values[1:bp])) {							object@rModels[[i]][[j]] <- setpars(object@rModels[[i]][[j]],values[1:bp])							# recompute observation densities if pars have changed							object@logdens[,j,i] <- logDens(object@rModels[[i]][[j]])						}					},					"fixed" = {						object@rModels[[i]][[j]] <- setpars(object@rModels[[i]][[j]],values[1:bp],which="fixed")					}				)					bp <- bp+1				values <- values[bp:length(values)]			}		}					return(object)	})	setMethod("getpars","hmModel",	function(object,which="pars",...) {		parameters <- getpars(object@initModel,which=which)		for(i in 1:object@nstates) {			parameters <- c(parameters,getpars(object@trModels[[i]],which=which))		}		for(i in 1:object@nstates) {			for(j in 1:object@nresp) {				parameters <- c(parameters,getpars(object@rModels[[i]][[j]],which=which))			}		}		return(parameters)	})