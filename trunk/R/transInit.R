# # for the transition models and the prior (y is missing, ie there is no# response, and nstates must be provided as the number of categories# neccessary in the mulinomial model)# setClass("transInit",contains="GLMresponse")# FIX ME: data is a necessary argument to determine the dimension of x, even when there# are no covariates (and there are by definition no responses ...)setMethod("transInit",	signature(formula="formula"),	function(formula,nstates,data=NULL,family=multinomial(),pstart=NULL,fixed=NULL,prob=TRUE, ...) {		call <- match.call()		mf <- match.call(expand.dots = FALSE)		m <- match(c("formula", "data"), names(mf), 0)		mf <- mf[c(1, m)]		mf$drop.unused.levels <- TRUE		mf[[1]] <- as.name("model.frame")		mf <- eval(mf, parent.frame())		x <- model.matrix(attr(mf, "terms"),mf)		y <- matrix(1,ncol=1) # y is not needed in the transition and init models		    		parameters <- list()		if(is.null(nstates)) stop("'nstates' must be provided in call to trinModel")		if(family$family=="multinomial") {			parameters$coefficients <- matrix(0,ncol=nstates,nrow=ncol(x))			if(is.null(fixed)) {				fixed <- parameters$coefficients				fixed[,family$base] <- 1 				fixed <- c(as.logical(t(fixed)))			}		}		npar <- length(unlist(parameters))		if(is.null(fixed)) fixed <- rep(0,npar)		if(!is.null(pstart)) {			if(length(pstart)!=npar) stop("length of 'pstart' must be ",npar)			if(family$family=="multinomial") {				if(prob) {					if(family$link=="identity") {						parameters$coefficients[1,] <- family$linkfun(pstart[1:ncol(parameters$coefficients)])					} else {						parameters$coefficients[1,] <- family$linkfun(pstart[1:ncol(parameters$coefficients)],base=family$base)					}				} else {					parameters$coefficients[1,] <- pstart[1:ncol(parameters$coefficients)]				}				pstart <- matrix(pstart,,ncol(x),byrow=TRUE)				if(ncol(x)>1) parameters$coefficients[2:ncol(x),] <- pstart[2:ncol(x),]			} else {				if(family$link=="identity") parameters$coefficients <- family$linkfun(pstart[1:length(parameters$coefficients)])				else parameters$coefficients <- family$linkfun(pstart[1:length(parameters$coefficients)],base=family$base)			}		}		mod <- switch(family$family,			multinomial = new("transInit",formula=formula,family=family,parameters=parameters,fixed=fixed,x=x,y=y,npar=npar),			new("transInit",formula=formula,family=family,parameters=parameters,fixed=fixed,x=x,y=y,npar=npar)		)		mod	})setMethod("logDens","transInit",	function(object) {		log(predict(object))	})setMethod("dens","transInit",	function(object,log=FALSE) {		if(log) log(predict(object))		else predict(object)	})setMethod("predict","transInit",	function(object) {		object@family$linkinv(object@x%*%object@parameters$coefficients,base=object@family$base)	})setMethod("fit","transInit",	function(object,w,ntimes) {		pars <- object@parameters		if(missing(w)) w <- NULL		oldfit <- function() {			tol <- 1e-5 # TODO: check global options			pars <- object@parameters			b <- pars$coefficients			base <- object@family$base			if(is.matrix(w)) nan <- which(is.na(rowSums(w))) else nan <- which(is.na(w))			#vgam(cbind(w[,-base],w[,base]) ~ ) # what is this?			y <- as.vector(t(object@family$linkinv(w[-c(nan,ntimes),-base],base=object@family$base)))			x <- object@x[-c(nan,ntimes),]						if(!is.matrix(x)) x <- matrix(x,ncol=ncol(object@x))			nt <- nrow(x)						Z <- matrix(ncol=length(b))			Z <- vector()			for(i in 1:nt) Z <- rbind(Z,t(bdiag(rep(list(x[i,]),ncol(w)-1))))						mu <- object@family$linkinv(x%*%b,base=base)						mt <- as.numeric(t(mu[,-base]))			Dl <- Sigmal <- Wl <- list()						converge <- FALSE			while(!converge) {				b.old <- b				for(i in 1:nt) {					Dl[[i]] <- object@family$mu.eta(mu[i,-base])					Sigmal[[i]] <- object@family$variance(mu[i,-base])					Wl[[i]] <- Dl[[i]]%*%solve(Sigmal[[i]])%*%t(Dl[[i]]) # TODO: 				}				Sigma <- bdiag(Sigmal)				D <- bdiag(Dl)				W <- bdiag(Wl)								b[,-base] <- as.numeric(b[,-base]) + solve(t(Z)%*%W%*%Z)%*%(t(Z)%*%D%*%solve(Sigma)%*%(y-mt))				if(abs(sum(b-b.old)) < tol) converge <- TRUE				mu <- object@family$linkinv(x%*%b,base=base)				mt <- as.numeric(t(mu[,-base]))			}			pars$coefficients <- t(b) # TODO: setpars gets matrix in wrong order!!! Fix this in setpars.			pars		}				vglmfit <- function() {					base <- object@family$base			w <- cbind(w[,-base],w[,base])			x <- slot(object,"x")			fam <- slot(object,"family")			fit <- vglm(w~x,fam)			pars$coefficients[,-base] <- t(slot(fit,coefficients))  # TODO: setpars gets matrix in wrong order!!! Fix this in setpars.			pars		}				nnetfit <- function() {			pars <- object@parameters			base <- object@family$base # delete me			#y <- object@y[,-base]			y <- object@y			x <- object@x			if(is.matrix(y)) na <- unlist(apply(y,2,function(x) which(is.na(x)))) else na <- which(is.na(y))			if(is.matrix(x)) na <- c(na,unlist(apply(x,2,function(x) which(is.na(x))))) else na <- c(na,which(is.na(x)))			if(!is.null(w)) na <- c(na,which(is.na(w)))			y <- as.matrix(y)			x <- as.matrix(x)			na <- unique(na)			x <- x[-na,]			y <- y[-na,]			y <- round(y) # delete me			if(!is.null(w)) w <- w[-na]			#mask <- matrix(1,nrow=nrow(pars$coefficients),ncol=ncol(pars$coefficients))			#mask[,base] <- 0			if(!is.null(w)) fit <- multinom(y~x-1,weights=w,trace=FALSE) else fit <- multinom(y~x-1,weights=w,trace=FALSE)			ids <- vector(,length=ncol(y))			ids[base] <- 1			ids[-base] <- 2:ncol(y)			pars$coefficients <- t(matrix(fit$wts,ncol=ncol(y))[-1,ids])			object <- setpars(object,unlist(pars))			#object			pars		}				pars <- object@parameters		base <- object@family$base # delete me		#y <- object@y[,-base]		y <- object@y		x <- object@x		if(is.matrix(y)) na <- unlist(apply(y,2,function(x) which(is.na(x)))) else na <- which(is.na(y))		if(is.matrix(x)) na <- c(na,unlist(apply(x,2,function(x) which(is.na(x))))) else na <- c(na,which(is.na(x)))		if(!is.null(w)) na <- c(na,which(is.na(w)))		y <- as.matrix(y)		x <- as.matrix(x)		na <- unique(na)		if(length(na)>0) {			x <- x[-na,]			y <- y[-na,]			#y <- round(y) # delete me			if(!is.null(w)) w <- w[-na]		}		mask <- matrix(1,nrow=nrow(pars$coefficients),ncol=ncol(pars$coefficients))		mask[,base] <- 0 # fix base category coefficients to 0		mask <- rbind(0,mask) # fix "bias" nodes to 0		Wts <- mask		Wts[-1,] <- pars$coefficients # set starting weights		Wts[Wts == Inf] <- .Machine$double.max.exp # Fix this!!!!		Wts[Wts == -Inf] <- .Machine$double.min.exp # Fix this!!!!!		if(!is.null(w)) {      fit <- nnet.default(x,y,weights=w,size=0,entropy=TRUE,skip=TRUE,mask=mask,Wts=Wts,trace=FALSE)    } else {      fit <- nnet.default(x,y,size=0,entropy=TRUE,skip=TRUE,mask=mask,Wts=Wts,trace=FALSE)    }		pars$coefficients <- t(matrix(fit$wts,ncol=ncol(pars$coefficients),nrow=nrow(pars$coefficients)+1)[-1,])		object <- setpars(object,unlist(pars))		object	})